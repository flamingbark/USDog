"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dappSchema = exports.chainAlias = exports.aliasSchema = exports.chainSchema = exports.hardhatConfigOverrides = exports.chainProvidersSchema = exports.chainProviderSchema = exports.chainExplorerSchema = exports.chainExplorerAPISchema = exports.chainExplorerAPIKeySchema = void 0;
const zod_1 = require("zod");
const chains_1 = require("./generated/chains");
const arrays_1 = require("./utils/arrays");
exports.chainExplorerAPIKeySchema = zod_1.z.object({
    required: zod_1.z.boolean(),
    hardhatEtherscanAlias: zod_1.z.string().optional(),
});
exports.chainExplorerAPISchema = zod_1.z.object({
    key: exports.chainExplorerAPIKeySchema,
    url: zod_1.z.url(),
});
exports.chainExplorerSchema = zod_1.z.object({
    api: exports.chainExplorerAPISchema.optional(),
    browserUrl: zod_1.z.url(),
});
exports.chainProviderSchema = zod_1.z
    .object({
    alias: zod_1.z.string(),
    homepageUrl: zod_1.z.url().optional(),
    rpcUrl: zod_1.z.url().optional(),
})
    .refine(
// Either rpcUrl or homepageUrl must be present
(provider) => provider.rpcUrl ?? provider.homepageUrl, {
    error: 'rpcUrl or homepageUrl is required',
});
exports.chainProvidersSchema = zod_1.z.array(exports.chainProviderSchema).superRefine((providers, ctx) => {
    if (!providers.some((p) => p.alias === 'default')) {
        ctx.issues.push({
            code: 'custom',
            path: [],
            message: "a provider with alias 'default' is required",
            input: providers.map((p) => p.alias),
        });
    }
    if (!(0, arrays_1.hasUniqueEntries)(providers, 'alias')) {
        ctx.issues.push({
            code: 'custom',
            path: [],
            message: "cannot contain duplicate 'alias' values",
            input: providers.map((p) => p.alias),
        });
    }
    providers.forEach((p, index) => {
        if ((p.alias === 'default' || p.alias === 'public') && !p.rpcUrl) {
            ctx.issues.push({
                code: 'custom',
                path: [index, 'rpcUrl'],
                message: "providers with alias 'default' or 'public' must also have an 'rpcUrl'",
                input: p.rpcUrl,
            });
        }
    });
});
exports.hardhatConfigOverrides = zod_1.z.object({
    networks: zod_1.z.record(zod_1.z.string(), zod_1.z.any()).optional(),
});
exports.chainSchema = zod_1.z.object({
    alias: zod_1.z.string(),
    decimals: zod_1.z.number().positive(),
    explorer: exports.chainExplorerSchema,
    hardhatConfigOverrides: exports.hardhatConfigOverrides.optional(),
    // Most chain IDs are numbers, but to remain flexible this has purposefully been kept as a string
    // It can be adjusted if we want to support chains that don't use numbers.
    // See: https://github.com/api3dao/chains/pull/1#discussion_r1161102392
    id: zod_1.z.string().regex(/^\d+$/),
    name: zod_1.z.string(),
    providers: exports.chainProvidersSchema,
    skipProviderCheck: zod_1.z.boolean().optional(), // For chains not supporting dAPIs
    symbol: zod_1.z.string().min(1).max(6),
    testnet: zod_1.z.boolean(),
});
exports.aliasSchema = zod_1.z.string().regex(/^[\da-z-]+$/);
exports.chainAlias = exports.aliasSchema.refine((value) => chains_1.CHAINS.some((chain) => chain.alias === value), {
    error: (issue) => `Invalid chain alias: ${issue.input}`,
});
exports.dappSchema = zod_1.z.strictObject({
    aliases: zod_1.z.record(exports.aliasSchema, zod_1.z.strictObject({
        chains: zod_1.z.array(exports.chainAlias),
        title: zod_1.z.string(),
        description: zod_1.z.string().optional(),
    })),
    homepageUrl: zod_1.z.url().optional(),
});
//# sourceMappingURL=types.js.map