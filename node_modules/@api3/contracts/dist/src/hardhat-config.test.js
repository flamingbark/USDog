"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chains_1 = require("./generated/chains");
const hardhat_config_1 = require("./hardhat-config");
const strings_1 = require("./utils/strings");
function getRandomChain() {
    return chains_1.CHAINS[Math.floor(Math.random() * chains_1.CHAINS.length)];
}
const OLD_ENV = process.env;
beforeEach(() => {
    jest.resetModules(); // Most important - it clears the cache
    process.env = { ...OLD_ENV }; // Make a copy
});
afterAll(() => {
    process.env = OLD_ENV; // Restore old environment
});
describe(hardhat_config_1.getEnvVariableNames.name, () => {
    it('returns an array with expected env variables', () => {
        const apiKeyEnvNames = chains_1.CHAINS.filter((chain) => chain.explorer?.api?.key?.required).map((chain) => (0, hardhat_config_1.etherscanApiKeyName)(chain));
        const networkRpcUrlNames = chains_1.CHAINS.map((chain) => (0, hardhat_config_1.networkHttpRpcUrlName)(chain));
        const expected = ['MNEMONIC', ...apiKeyEnvNames, ...networkRpcUrlNames];
        expect((0, hardhat_config_1.getEnvVariableNames)()).toStrictEqual(expected);
    });
});
describe(hardhat_config_1.etherscanApiKeyName.name, () => {
    it('returns the expected Etherscan API key name', () => {
        const randomChain = getRandomChain();
        const expected = `ETHERSCAN_API_KEY_${(0, strings_1.toUpperSnakeCase)(randomChain.alias)}`;
        expect((0, hardhat_config_1.etherscanApiKeyName)(randomChain)).toStrictEqual(expected);
    });
});
describe(hardhat_config_1.networkHttpRpcUrlName.name, () => {
    it('returns the expected HTTP RPC URL name', () => {
        const randomChain = getRandomChain();
        const expected = `ETHERSCAN_API_KEY_${(0, strings_1.toUpperSnakeCase)(randomChain.alias)}`;
        expect((0, hardhat_config_1.etherscanApiKeyName)(randomChain)).toStrictEqual(expected);
    });
});
describe(hardhat_config_1.etherscan.name, () => {
    beforeEach(() => {
        // eslint-disable-next-line jest/no-standalone-expect
        expect(global.window).toBeUndefined();
    });
    afterEach(() => {
        delete global.window;
    });
    it('throws an error if called in a browser-like environment', () => {
        global.window = {};
        expect(() => (0, hardhat_config_1.etherscan)()).toThrow('Cannot be called outside of a Node.js environment');
    });
    describe('customChains', () => {
        it('ignores chains without an explorer', () => {
            const { customChains } = (0, hardhat_config_1.etherscan)();
            const ids = chains_1.CHAINS.filter((c) => !c.explorer).map((c) => c.id);
            customChains.forEach((c) => {
                expect(ids).not.toContain(c.chainId);
            });
        });
        it('ignores chains without an explorer API', () => {
            const { customChains } = (0, hardhat_config_1.etherscan)();
            const ids = chains_1.CHAINS.filter((c) => !!c.explorer && !c.explorer.api).map((c) => c.id);
            customChains.forEach((c) => {
                expect(ids).not.toContain(c.chainId);
            });
        });
        it('ignores chains with a hardhat etherscan alias', () => {
            const { customChains } = (0, hardhat_config_1.etherscan)();
            const chains = chains_1.CHAINS.filter((c) => !!c.explorer && !!c.explorer.api);
            const ids = chains.filter((c) => c.explorer.api.key.hardhatEtherscanAlias).map((c) => c.id);
            customChains.forEach((c) => {
                expect(ids).not.toContain(c.chainId);
            });
        });
        it('includes all other chains', () => {
            const { customChains } = (0, hardhat_config_1.etherscan)();
            const chains = chains_1.CHAINS.filter((c) => !!c.explorer && !!c.explorer.api);
            const chainsWithoutAlias = chains.filter((c) => !c.explorer.api.key.hardhatEtherscanAlias);
            customChains.forEach((customChain) => {
                const chain = chainsWithoutAlias.find((c) => c.id === customChain.chainId.toString());
                expect(customChain).toStrictEqual({
                    network: chain.alias,
                    chainId: Number(chain.id),
                    urls: {
                        apiURL: chain.explorer.api.url,
                        browserURL: chain.explorer.browserUrl,
                    },
                });
            });
        });
    });
    describe('apiKey', () => {
        it('ignores chains without an explorer', () => {
            const { apiKey } = (0, hardhat_config_1.etherscan)();
            const aliases = chains_1.CHAINS.filter((c) => !c.explorer).map((c) => c.alias);
            Object.keys(apiKey).forEach((key) => {
                expect(aliases).not.toContain(key);
            });
        });
        it('ignores chains without an explorer API', () => {
            const { apiKey } = (0, hardhat_config_1.etherscan)();
            const aliases = chains_1.CHAINS.filter((c) => !!c.explorer && !c.explorer.api).map((c) => c.alias);
            Object.keys(apiKey).forEach((key) => {
                expect(aliases).not.toContain(key);
            });
        });
        it('sets the API key value to dummy value for chains with a hardhat alias', () => {
            const chains = chains_1.CHAINS.filter((c) => !!c.explorer && !!c.explorer.api);
            const chainsWithAlias = chains.filter((c) => {
                return (!!c.explorer.api.key.hardhatEtherscanAlias && // has a hardhatEtherscanAlias
                    !c.explorer.api.key.required); // but not required
            });
            const { apiKey } = (0, hardhat_config_1.etherscan)();
            chainsWithAlias.forEach((chain) => {
                expect(apiKey[chain.explorer.api.key.hardhatEtherscanAlias]).toBe('DUMMY_VALUE');
            });
        });
        it('sets the API key value to not found for chains with a hardhat alias', () => {
            const chains = chains_1.CHAINS.filter((c) => !!c.explorer && !!c.explorer.api);
            const chainsWithAlias = chains.filter((c) => {
                return (!!c.explorer.api.key.hardhatEtherscanAlias && // has a hardhatEtherscanAlias
                    c.explorer.api.key.required); // and is required
            });
            const { apiKey } = (0, hardhat_config_1.etherscan)();
            chainsWithAlias.forEach((chain) => {
                expect(apiKey[chain.explorer.api.key.hardhatEtherscanAlias]).toBe('NOT_FOUND');
            });
        });
        it('sets the API value to the env variable value for chains with a hardhat alias', () => {
            const chains = chains_1.CHAINS.filter((c) => !!c.explorer && !!c.explorer.api);
            const chainsWithAlias = chains.filter((c) => {
                return (!!c.explorer.api.key.hardhatEtherscanAlias && // has a hardhatEtherscanAlias
                    c.explorer.api.key.required); // and is required
            });
            chainsWithAlias.forEach((chain) => {
                const envKey = (0, hardhat_config_1.etherscanApiKeyName)(chain);
                process.env[envKey] = `api-key-${chain.id}`;
            });
            // needs to be called AFTER env values are set
            const { apiKey } = (0, hardhat_config_1.etherscan)();
            chainsWithAlias.forEach((chain) => {
                expect(apiKey[chain.explorer.api.key.hardhatEtherscanAlias]).toBe(`api-key-${chain.id}`);
            });
        });
    });
});
describe(hardhat_config_1.networks.name, () => {
    beforeEach(() => {
        // eslint-disable-next-line jest/no-standalone-expect
        expect(global.window).toBeUndefined();
    });
    afterEach(() => {
        delete global.window;
    });
    it('throws an error if called in a browser-like environment', () => {
        global.window = {};
        expect(() => (0, hardhat_config_1.networks)()).toThrow('Cannot be called outside of a Node.js environment');
    });
    it('builds a network object for each chain', () => {
        const result = (0, hardhat_config_1.networks)();
        expect(Object.keys(result)).toHaveLength(chains_1.CHAINS.length);
        chains_1.CHAINS.forEach((chain) => {
            const defaultProvider = chain.providers.find((p) => p.alias === 'default');
            const overrides = chain.hardhatConfigOverrides?.networks ?? {};
            expect(result[chain.alias]).toStrictEqual({
                accounts: { mnemonic: '' },
                chainId: Number(chain.id),
                url: defaultProvider.rpcUrl,
                ...overrides,
            });
        });
    });
    it('sets the mnemonic using the MNEMONIC env variable if it exists', () => {
        process.env.MNEMONIC = 'test test test test test test test test test test test junk';
        const result = (0, hardhat_config_1.networks)();
        chains_1.CHAINS.forEach((chain) => {
            const defaultProvider = chain.providers.find((p) => p.alias === 'default');
            const overrides = chain.hardhatConfigOverrides?.networks ?? {};
            expect(result[chain.alias]).toStrictEqual({
                accounts: { mnemonic: 'test test test test test test test test test test test junk' },
                chainId: Number(chain.id),
                url: defaultProvider.rpcUrl,
                ...overrides,
            });
        });
    });
    it('sets the provider URL using the chain alias env variable if it exists', () => {
        chains_1.CHAINS.forEach((chain) => {
            const alias = (0, strings_1.toUpperSnakeCase)(chain.alias);
            process.env[`HARDHAT_HTTP_RPC_URL_${alias}`] = `https://${chain.id}.xyz`;
        });
        const result = (0, hardhat_config_1.networks)();
        chains_1.CHAINS.forEach((chain) => {
            const overrides = chain.hardhatConfigOverrides?.networks ?? {};
            expect(result[chain.alias]).toStrictEqual({
                accounts: { mnemonic: '' },
                chainId: Number(chain.id),
                url: `https://${chain.id}.xyz`,
                ...overrides,
            });
        });
    });
});
//# sourceMappingURL=hardhat-config.test.js.map